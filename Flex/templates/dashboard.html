{% extends "base.html" %}
{% block content %}

<!-- Optional: Inline styles for canvas layering and notification banner (can be moved to style.css if desired) -->
<style>
  /* Canvas container specific to the graph */
  .canvas-container {
    position: relative;
    width: 600px;
    height: 300px;
    border: 1px solid #ccc;
    background: transparent; /* transparent background */
    margin: 0 auto; /* center the canvas */
  }
  .canvas-container canvas {
    position: absolute;
    top: 0;
    left: 0;
  }
  .feedback-description {
    font-size: 14px;
    color: #dddddd;
    text-align: center;
    margin-top: 10px;
    margin-bottom: 10px;
  }
  /* Wrap the score and warning banner together */
  #scoreWrapper {
    position: relative;
    width: 600px;
    margin: 0 auto;
  }
  /* Score container styling */
  #scoreContainer {
    text-align: center;
    font-size: 20px;
    font-weight: bold;
    padding: 20px 0; /* add some vertical padding */
  }
  /* Red banner notification styling - positioned absolutely so it overlays the score area */
  #shoulderWarning {
    position: absolute;
    top: 0; /* adjust this value if needed */
    left: 0;
    width: 100%;
    text-align: center;
    background-color: #ff4d4d;
    color: white;
    padding: 5px;
    z-index: 10;
    display: none; /* hidden by default */
  }
  /* Feedback box styling */
  .feedback-box {
    text-align: center;
    margin-bottom: 20px;
  }
</style>

<div class="dashboard-container">
  {% if current_user.is_authenticated %}
    <h2>Live Workout Feedback</h2>
    <p class="feedback-description">
      Monitor your form in real-time and receive instant feedback.
      For example, as you perform a bicep curl, the graph below tracks the movement of your arm.
      When your movement closely matches the target curve, you earn points!
    </p>
    
    <!-- Score and warning container -->
    <div id="scoreWrapper">
      <div id="scoreContainer">
        Score: <span id="scoreDisplay">0</span> | Reps: <span id="repCount">0</span>
      </div>
      <div id="shoulderWarning">
        Shoulder movement detected! Please keep your shoulders stable during a bicep curl.
      </div>
    </div>

    <!-- Graph area (you can update the header if desired) -->
    <div class="feedback-box">
      <h3>Score Target</h3>
      <div class="canvas-container">
        <!-- Background layer: Preâ€‘drawn target curve -->
        <canvas id="backgroundCanvas" width="600" height="300"></canvas>
        <!-- Foreground layer: Cursor showing live sensor data -->
        <canvas id="cursorCanvas" width="600" height="300"></canvas>
      </div>
    </div>
  {% else %}
    <div class="please-login-message">
      <h2>Welcome to FLEX</h2>
      <p>You must be logged in to view live feedback.</p>
      <a href="{{ url_for('login') }}" class="login-btn">Log In Now</a>
    </div>
  {% endif %}
</div>

<!-- Include Socket.IO -->
<script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>

<script>
  
document.addEventListener('DOMContentLoaded', function() {
  // Canvas and animation configuration
  const canvasWidth = 600;
  const canvasHeight = 300;
  const cycleDuration = 6.5; // seconds per full cycle: 3s at 0, 1s ramp-up, 1s at top, 1.5s ramp-down
  const scrollSpeed = canvasWidth / cycleDuration; // pixels per second
  const noDataThreshold = 1000; // ms: update background only if recent data received
  const minPitch = -20;
  const maxPitch = 110;
  const pitchRange = maxPitch - minPitch; // 130 degrees total

  // Scoring variables
  let score = 0;
  const scoreIncrement = 1; // Adjust scoring rate as desired
  let lastScoreTime = performance.now();

  // Global variable for shoulder movement detection.
  let shoulderMovementDetected = false;

  // Get canvas elements and contexts
  const bgCanvas = document.getElementById('backgroundCanvas');
  const bgCtx = bgCanvas.getContext('2d');
  const cursorCanvas = document.getElementById('cursorCanvas');
  const cursorCtx = cursorCanvas.getContext('2d');

  // Get the shoulder warning banner element.
  const shoulderWarningBanner = document.getElementById('shoulderWarning');

  // Global variables for sensor data and animation
  let lastDataTime = 0;         // Timestamp of the last sensor data (in ms)
  let globalOffset = 0;         // Horizontal offset for background scrolling
  let lastTimestamp;            // For calculating delta time between frames
  let currentPitch = 0;         // Latest sensor pitch value
  let smoothedPitch = 0;        // Smoothed pitch for cursor display

  // Load the cursor image (sprite)
  const spiritImg = new Image();
  spiritImg.onload = function() {
    console.log('Sprite image loaded.');
  };
  spiritImg.src = "{{ url_for('static', filename='images/sprite.png') }}";

  // Easing functions for curved transitions:
  function easeInQuad(t) {
    return t * t;
  }
  function easeOutQuad(t) {
    return t * (2 - t);
  }

  // Draw a light grid for visual consistency.
  function drawGrid(ctx) {
    const gridColor = 'rgba(0, 0, 0, 0.1)';
    ctx.strokeStyle = gridColor;
    ctx.lineWidth = 1;
    for (let x = 0; x <= canvasWidth; x += 50) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvasHeight);
      ctx.stroke();
    }
    for (let y = 0; y <= canvasHeight; y += 50) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvasWidth, y);
      ctx.stroke();
    }
  }

  // Draw one cycle of the pre-defined target pattern.
  function drawCycle(ctx, offsetX) {
    ctx.beginPath();
    for (let x = 0; x <= canvasWidth; x++) {
      // Compute time along the cycle.
      let t = ((x + offsetX) / canvasWidth) * cycleDuration;
      t = t % cycleDuration;
      let pitch;
      if (t < 3) {
        pitch = 0;
      } else if (t < 4) {
        let u = (t - 3) / 1;
        pitch = 90 * easeInQuad(u);
      } else if (t < 5) {
        pitch = 90;
      } else if (t < 6.5) {
        let u = (t - 5) / 1.5;
        pitch = 90 * (1 - easeOutQuad(u));
      }
      let y = canvasHeight - ((pitch - minPitch) / pitchRange) * canvasHeight;
      if (x === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.strokeStyle = 'rgba(75, 192, 192, 1)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  // Animate the background (scrolling target curve).
  function animateBackground(timestamp) {
    if (!lastTimestamp) lastTimestamp = timestamp;
    let dt = (timestamp - lastTimestamp) / 1000; // delta time in seconds
    lastTimestamp = timestamp;
    if (timestamp - lastDataTime < noDataThreshold) {
      globalOffset = (globalOffset + scrollSpeed * dt) % canvasWidth;
    }
    bgCtx.clearRect(0, 0, canvasWidth, canvasHeight);
    drawGrid(bgCtx);
    drawCycle(bgCtx, globalOffset);
    // Draw a second copy shifted left for seamless scrolling.
    bgCtx.save();
    bgCtx.translate(-canvasWidth, 0);
    drawCycle(bgCtx, globalOffset);
    bgCtx.restore();
    requestAnimationFrame(animateBackground);
  }
  requestAnimationFrame(animateBackground);

  // Draw the moving cursor (performance indicator) and update score.
  function drawCursor() {
    // Smooth the sensor pitch.
    smoothedPitch += (currentPitch - smoothedPitch) * 0.1;
    cursorCtx.clearRect(0, 0, canvasWidth, canvasHeight);
    const fixedX = 100;
    // Map the sensor value to a vertical position.
    let y = canvasHeight - ((smoothedPitch - minPitch) / pitchRange) * canvasHeight;
    
    // Draw the sprite at 32x32 pixels, centered at (fixedX, y)
    if (spiritImg.complete && spiritImg.naturalWidth !== 0) {
      cursorCtx.drawImage(spiritImg, fixedX - 16, y - 16, 32, 32);
    }
    
    // Calculate the expected target value at fixedX using the same cycle.
    let t = ((fixedX + globalOffset) / canvasWidth) * cycleDuration;
    t = t % cycleDuration;
    let expectedPitch;
    if (t < 3) {
      expectedPitch = 0;
    } else if (t < 4) {
      expectedPitch = 90 * easeInQuad((t - 3) / 1);
    } else if (t < 5) {
      expectedPitch = 90;
    } else if (t < 6.5) {
      expectedPitch = 90 * (1 - easeOutQuad((t - 5) / 1.5));
    }
    let expectedY = canvasHeight - ((expectedPitch - minPitch) / pitchRange) * canvasHeight;
    
    // Set tolerance: 10% of canvas height.
    const tolerance = 0.1 * canvasHeight;
    
    // Only award points if shoulder movement is NOT detected.
    if (!shoulderMovementDetected && Math.abs(y - expectedY) < tolerance) {
      let now = performance.now();
      score += Math.floor((now - lastScoreTime) * scoreIncrement / 1000);
      lastScoreTime = now;
      // Update only the score display.
      document.getElementById("scoreDisplay").textContent = score;
    }
    
    requestAnimationFrame(drawCursor);
  }
  requestAnimationFrame(drawCursor);

  // Connect to the Socket.IO server to receive sensor data.
// Store aggregated data in an array
let aggregatedData = [];

// Listen for incoming sensor data
const socket = io();
socket.on('connect', function() {
    console.log('Connected to server via Socket.IO.');
});

let shoulderWarningTimeout;

socket.on('sensor_data', function(data) {
    if (data.pitch !== undefined) {
        currentPitch = data.pitch;
        lastDataTime = performance.now();

        // Append pitch data to the aggregated array
        aggregatedData.push({
            timestamp: new Date().toISOString(),
            pitch: data.pitch,
            shoulder_movement: data.shoulder_movement || 0,
            rep_count: data.rep_count || 0
        });
    }

    // Handle shoulder movement warning
    if (data.shoulder_movement !== undefined) {
        if (data.shoulder_movement > 8) {
            shoulderMovementDetected = true;
            shoulderWarningBanner.style.display = "block";
            clearTimeout(shoulderWarningTimeout);
            shoulderWarningTimeout = setTimeout(function() {
                shoulderMovementDetected = false;
                shoulderWarningBanner.style.display = "none";
            }, 3000);
        }
    }

    // Update rep count in UI
    if (data.rep_count !== undefined) {
        document.getElementById("repCount").textContent = data.rep_count;
    }

    // **Trigger when session ends**
    print("Data: ", data);
    if (data.end === true) {
        console.log("Workout session ended. Sending aggregated data...");

        sendMetricsData({
            session_id: new Date().getTime(), // Unique session identifier
            metrics: aggregatedData // Send collected data
        });

        // Reset aggregated data for next session
        aggregatedData = [];
    }
});

    // Replace with your EC2 instance's public IPv4 DNS or public IP
  const EC2_SERVER_URL = "http://ec2-184-73-86-153.compute-1.amazonaws.com:5000";


function sendMetricsData(aggregatedData) {
  fetch(`${EC2_SERVER_URL}/save_metrics`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ test: "Hello EC2!" })
})
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.error(error));
  
  // fetch(`${EC2_SERVER_URL}/save_metrics`, {
    //     method: 'POST',
    //     headers: { 'Content-Type': 'application/json' },
    //     body: JSON.stringify(aggregatedData)
    // })
    // .then(response => response.json())
    // .then(data => console.log('Server Response:', data))
    // .catch(error => console.error('Error:', error));
}

  });
</script>

{% endblock %}
