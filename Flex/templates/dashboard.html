{% extends "base.html" %}
{% block content %}

<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

  /* Retro Title and Scoreboard */
  .game-title {
    text-align: center;
    font-size: 2rem;
    color: #ff4d00;
    font-family: 'Press Start 2P', cursive;
    margin-bottom: 1rem;
    text-shadow: 3px 3px #000;
  }
  .scoreboard {
    margin: 1rem auto;
    text-align: center;
    font-size: 1.5rem;
    color: #ffea00;
    font-weight: bold;
    font-family: 'Press Start 2P', cursive;
    animation: scoreFlash 0.5s ease-in-out infinite alternate;
  }
  @keyframes scoreFlash {
    from { transform: scale(1); color: #ffea00; }
    to   { transform: scale(1.2); color: #ff4d00; }
  }

  /* Canvas container (600×300) */
  .canvas-container {
    position: relative;
    width: 600px;
    height: 300px;
    border: 1px solid #ccc;
    background: transparent;
    margin: 0 auto;
  }
  .canvas-container canvas {
    position: absolute;
    top: 0;
    left: 0;
  }

  /* Descriptive text */
  .feedback-description {
    font-size: 14px;
    color: #dddddd;
    text-align: center;
    margin-top: 10px;
    margin-bottom: 10px;
  }

  /* Shoulder warning banner */
  #shoulderWarning {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    text-align: center;
    background-color: #ff4d4d;
    color: white;
    padding: 5px;
    z-index: 10;
    display: none;
  }

  /* Feedback box around the graph */
  .feedback-box {
    text-align: center;
    margin-bottom: 20px;
  }

  /* Retro End Workout Button */
  #endWorkoutBtn {
    display: block;
    margin: 1rem auto;
    padding: 10px 20px;
    font-size: 1rem;
    font-family: 'Press Start 2P', cursive;
    color: #fff;
    background: #ff4d00;
    border: none;
    cursor: pointer;
    transition: 0.3s;
  }
  #endWorkoutBtn:hover {
    background: #ffea00;
    color: #000;
  }

  /* Server output text */
  #serverOutput {
    text-align: center;
    margin-top: 20px;
    font-size: 16px;
    color: #ffffff; /* from your teammate’s code */
  }

  /* Metrics results container (local analysis) */
  #metricsResults {
    text-align: center;
    margin-top: 20px;
    font-size: 16px;
    color: #333;
  }
  #metricsResults h3 {
    margin-bottom: 10px;
  }
  #metricsResults p {
    margin: 4px 0;
  }

  /* Gauge canvas for Good Reps */
  #goodRepsGauge {
    display: block;
    margin: 1rem auto;
    background: #222;
    border-radius: 10px;
  }
</style>

<div class="dashboard-container">
  {% if current_user.is_authenticated %}
    <!-- Retro SINC Title -->
    <h2 class="game-title">SINC</h2>

    <!-- Retro scoreboard -->
    <div class="scoreboard">
      Score: <span id="scoreDisplay">0</span> | Reps: <span id="repCount">0</span>
    </div>

    <p class="feedback-description">
      Monitor your form in real-time and receive instant feedback.
      For example, as you perform a bicep curl, the graph below tracks the movement of your arm.
      When your movement closely matches the target curve, you earn points!
    </p>

    <!-- Graph area -->
    <div class="feedback-box">
      <h3>Score Target</h3>
      <div class="canvas-container">
        <canvas id="backgroundCanvas" width="600" height="300"></canvas>
        <canvas id="cursorCanvas" width="600" height="300"></canvas>
        <div id="shoulderWarning">Shoulder movement detected! Please keep your shoulders stable.</div>
      </div>
    </div>

    <!-- End Workout button -->
    <button id="endWorkoutBtn">End Workout</button>

    <!-- Server output -->
    <div id="serverOutput"></div>

    <!-- Local analysis area (set metrics + bar chart) -->
    <div id="metricsResults">
      <canvas id="repComparisonChart" width="600" height="400"></canvas>
    </div>

    <!-- Processed (remote) results area -->
    <div id="processedResults" style="text-align: center; margin-top: 20px;"></div>

  {% else %}
    <div class="please-login-message">
      <h2>Welcome to FLEX</h2>
      <p>You must be logged in to view live feedback.</p>
      <a href="{{ url_for('login') }}" class="login-btn">Log In Now</a>
    </div>
  {% endif %}
</div>

<!-- Include Socket.IO, local analysis scripts, and chart.js -->
<script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>
<script src="{{ url_for('static', filename='rep_data_processor.js') }}"></script>
<script src="{{ url_for('static', filename='set_analysis.js') }}"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="{{ url_for('static', filename='bar_chart.js') }}"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  /*-------------------------------------
    Canvas/Animation Setup (600×300)
  -------------------------------------*/
  const canvasWidth = 600;
  const canvasHeight = 300;
  const cycleDuration = 6.5; // seconds per cycle
  const scrollSpeed = canvasWidth / cycleDuration;
  const noDataThreshold = 1000; // ms
  const minPitch = -20;
  const maxPitch = 110;
  const pitchRange = maxPitch - minPitch;

  let score = 0;
  const scoreIncrement = 1;
  let lastScoreTime = performance.now();
  let lastDataTime = 0;
  let globalOffset = 0;
  let lastTimestamp;
  let currentPitch = 0;
  let smoothedPitch = 0;
  let shoulderMovementDetected = false;

  // Canvas references
  const bgCanvas = document.getElementById('backgroundCanvas');
  const bgCtx = bgCanvas.getContext('2d');
  const cursorCanvas = document.getElementById('cursorCanvas');
  const cursorCtx = cursorCanvas.getContext('2d');
  const shoulderWarningBanner = document.getElementById('shoulderWarning');

  // Sprite
  const spiritImg = new Image();
  spiritImg.src = "{{ url_for('static', filename='images/sprite.png') }}";

  function easeInQuad(t) { return t * t; }
  function easeOutQuad(t) { return t * (2 - t); }

  // (Optional) drawGrid for debugging
  function drawGrid(ctx) {
    const gridColor = 'rgba(0, 0, 0, 0.1)';
    ctx.strokeStyle = gridColor;
    ctx.lineWidth = 1;
    for (let x = 0; x <= canvasWidth; x += 50) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvasHeight);
      ctx.stroke();
    }
    for (let y = 0; y <= canvasHeight; y += 50) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvasWidth, y);
      ctx.stroke();
    }
  }

  function drawCycle(ctx, offsetX) {
    ctx.beginPath();
    for (let x = 0; x <= canvasWidth; x++) {
      let t = ((x + offsetX) / canvasWidth) * cycleDuration;
      t = t % cycleDuration;
      let pitch;
      if (t < 3) {
        pitch = 0;
      } else if (t < 4) {
        let u = (t - 3) / 1;
        pitch = 90 * easeInQuad(u);
      } else if (t < 5) {
        pitch = 90;
      } else if (t < 6.5) {
        let u = (t - 5) / 1.5;
        pitch = 90 * (1 - easeOutQuad(u));
      }
      let y = canvasHeight - ((pitch - minPitch) / pitchRange) * canvasHeight;
      if (x === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.strokeStyle = 'rgba(75, 192, 192, 1)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function animateBackground(timestamp) {
    if (!lastTimestamp) lastTimestamp = timestamp;
    let dt = (timestamp - lastTimestamp) / 1000;
    lastTimestamp = timestamp;

    if (timestamp - lastDataTime < noDataThreshold) {
      globalOffset = (globalOffset + scrollSpeed * dt) % canvasWidth;
    }
    bgCtx.clearRect(0, 0, canvasWidth, canvasHeight);
    // drawGrid(bgCtx); // optional
    drawCycle(bgCtx, globalOffset);

    bgCtx.save();
    bgCtx.translate(-canvasWidth, 0);
    drawCycle(bgCtx, globalOffset);
    bgCtx.restore();

    requestAnimationFrame(animateBackground);
  }
  requestAnimationFrame(animateBackground);

  function drawCursor() {
    smoothedPitch += (currentPitch - smoothedPitch) * 0.1;
    cursorCtx.clearRect(0, 0, canvasWidth, canvasHeight);

    const fixedX = 100;
    let y = canvasHeight - ((smoothedPitch - minPitch) / pitchRange) * canvasHeight;
    if (spiritImg.complete && spiritImg.naturalWidth !== 0) {
      cursorCtx.drawImage(spiritImg, fixedX - 16, y - 16, 32, 32);
    }

    let t = ((fixedX + globalOffset) / canvasWidth) * cycleDuration;
    t = t % cycleDuration;
    let expectedPitch;
    if (t < 3) {
      expectedPitch = 0;
    } else if (t < 4) {
      expectedPitch = 90 * easeInQuad((t - 3) / 1);
    } else if (t < 5) {
      expectedPitch = 90;
    } else if (t < 6.5) {
      expectedPitch = 90 * (1 - easeOutQuad((t - 5) / 1.5));
    }
    let expectedY = canvasHeight - ((expectedPitch - minPitch) / pitchRange) * canvasHeight;
    const tolerance = 0.1 * canvasHeight;
    if (!shoulderMovementDetected && Math.abs(y - expectedY) < tolerance) {
      let now = performance.now();
      score += Math.floor((now - lastScoreTime) * scoreIncrement / 1000);
      lastScoreTime = now;
      document.getElementById("scoreDisplay").textContent = score;
    }

    requestAnimationFrame(drawCursor);
  }
  requestAnimationFrame(drawCursor);

  /*-------------------------------------
    Socket.IO + Rep Processing
  -------------------------------------*/
  const socket = io();
  let repProcessor = new RepDataProcessor();
  let shoulderWarningTimeout;

  socket.on('connect', () => {
    console.log('Connected to server via Socket.IO.');
  });

  socket.on('sensor_data', data => {
    // Update pitch
    if (data.pitch !== undefined) {
      currentPitch = data.pitch;
      lastDataTime = performance.now();
    }
    // Shoulder movement
    if (data.shoulder_movement !== undefined && data.shoulder_movement > 15) {
      shoulderMovementDetected = true;
      shoulderWarningBanner.style.display = "block";
      clearTimeout(shoulderWarningTimeout);
      shoulderWarningTimeout = setTimeout(() => {
        shoulderMovementDetected = false;
        shoulderWarningBanner.style.display = "none";
      }, 3000);
    }
    // Reps
    if (data.rep_count !== undefined) {
      document.getElementById("repCount").textContent = data.rep_count;
    }
    // Rep processor
    if (data.pitch !== undefined && data.gyro !== undefined && data.shoulder_movement !== undefined) {
      repProcessor.update(data.pitch, data.gyro, data.shoulder_movement);
    }
    if (data.rep_count !== undefined && data.rep_count > repProcessor.reps.length) {
      repProcessor.storeRep(data.rep_count);
    }

    // End of set => local + remote analysis
    if (data.end === 1) {
      console.log("Workout set ended. Running local analysis & sending data...");
      let aggregatedMetrics = repProcessor.getAggregatedData();

      // 1) Local analysis
      displayLocalAnalysis(aggregatedMetrics);

      // 2) (Optional) remote analysis
      sendMetricsData({
        session_id: new Date().getTime(),
        metrics: aggregatedMetrics
      });

      repProcessor.reset();
    }
  });

  /*-------------------------------------
    Remote Analysis
  -------------------------------------*/
  const EC2_SERVER_URL = "http://ec2-44-201-164-184.compute-1.amazonaws.com:5000";

  function pollProcessedResults() {
    fetch(EC2_SERVER_URL + "/get_processed_results", { method: "GET" })
      .then(res => res.json())
      .then(processedData => {
        if (processedData.status === "processing") {
          setTimeout(pollProcessedResults, 2000);
        } else {
          console.log("Remote processed data:", processedData);
          displayProcessedResults(processedData);
          document.getElementById("serverOutput").textContent = "Processing complete!";
        }
      })
      .catch(error => {
        console.error("Error polling processed results:", error);
        document.getElementById("serverOutput").textContent = "Error fetching processed results.";
      });
  }

  function sendMetricsData(aggregatedData) {
    const serverOutput = document.getElementById("serverOutput");
    serverOutput.textContent = "Processing data...";

    fetch(EC2_SERVER_URL + "/save_metrics", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(aggregatedData)
    })
    .then(res => res.json())
    .then(data => {
      console.log("Server Response:", data);
      if (data.status === "processing" || data.status === "success") {
        serverOutput.textContent = "Processing complete! Fetching results...";
        pollProcessedResults();
      } else {
        serverOutput.textContent = "Error: " + data.message;
      }
    })
    .catch(error => {
      console.error("Error:", error);
      serverOutput.textContent = "Error sending data.";
    });
  }

  /*-------------------------------------
    Local Analysis + Gauge
  -------------------------------------*/
  function displayLocalAnalysis(aggregatedData) {
  // 1) Update status message
  const serverOutput = document.getElementById("serverOutput");
  serverOutput.textContent = "Local analysis complete!";

  // 2) Compute set metrics & recommendations
  const analysis = computeSetMetrics(aggregatedData);
  const metricsContainer = document.getElementById("metricsResults");

  // Create a wrapper for analysis text to avoid wiping out existing canvases
  let analysisWrapper = document.createElement("div");
  analysisWrapper.innerHTML = `<h3 class="game-title">Set Metrics & Recommendations</h3>`;

  if (analysis) {
    // Build metric details
    let metricHTML = `<div class="metrics-box">`;
    for (const feat in analysis.metrics) {
      const featData = analysis.metrics[feat];
      metricHTML += `
        <p>
          <strong>${feat}:</strong> Early = ${featData.early.toFixed(2)}, 
          Late = ${featData.late.toFixed(2)}
          <span class="metric-trend">(${featData.trend} by ${Math.abs(featData.difference).toFixed(2)})</span>
        </p>`;
    }
    metricHTML += `</div>`;
    analysisWrapper.innerHTML += metricHTML;

    // Build recommendations list
    let recHTML = `<h4>Recommendations:</h4><ul class="recommendations-list">`;
    analysis.recommendations.forEach(rec => {
      recHTML += `<li>${rec}</li>`;
    });
    recHTML += `</ul>`;
    analysisWrapper.innerHTML += recHTML;

    // Append the analysis content without disturbing the existing canvases
    metricsContainer.insertAdjacentElement("afterbegin", analysisWrapper);

    // Use the existing static bar chart canvas if present; otherwise, add it.
    if (!document.getElementById("repComparisonChart")) {
      metricsContainer.insertAdjacentHTML("beforeend", `<canvas id="repComparisonChart" width="600" height="400"></canvas>`);
    }
    displayBarChart(analysis.metrics, metricsContainer, "repComparisonChart");
  } else {
    metricsContainer.insertAdjacentHTML("beforeend", `<p>Not enough data to compute metrics.</p>`);
  }

  // 3) Show Good Reps Gauge—append only if it isn’t already there.
  const totalReps = aggregatedData.reps.length;
  const goodReps = aggregatedData.reps.filter(r => r.cluster === 1).length;
  if (!document.getElementById("goodRepsGauge")) {
    const gaugeHTML = `
      <div class="gauge-container">
        <h3>Good Reps Gauge</h3>
        <canvas id="goodRepsGauge" width="200" height="100"></canvas>
      </div>
    `;
    metricsContainer.insertAdjacentHTML("beforeend", gaugeHTML);
  }
  updateGoodRepsGauge(goodReps, totalReps);
}

  /*-------------------------------------
    Good Reps Gauge
  -------------------------------------*/
  let gaugeFill = 0;
  function drawGauge(fillRatio, ctx, w, h, goodReps, totalReps) {
    ctx.clearRect(0, 0, w, h);

    // Background arc
    ctx.beginPath();
    ctx.arc(w/2, h, 80, Math.PI, 2*Math.PI);
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 20;
    ctx.stroke();

    // Filled arc
    ctx.beginPath();
    ctx.arc(w/2, h, 80, Math.PI, Math.PI + Math.PI * fillRatio, false);
    ctx.strokeStyle = '#ff4d00';
    ctx.lineWidth = 20;
    ctx.stroke();

    // Text
    ctx.font = '16px "Press Start 2P", cursive';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.fillText(`${goodReps}/${totalReps} Good Reps`, w/2, h - 90);
  }

  function updateGoodRepsGauge(goodReps, totalReps) {
    const gaugeCanvas = document.getElementById("goodRepsGauge");
    if (!gaugeCanvas) return;
    const ctx = gaugeCanvas.getContext('2d');
    const w = gaugeCanvas.width;
    const h = gaugeCanvas.height;

    const targetFill = totalReps ? goodReps / totalReps : 0;
    const animationDuration = 500; // ms
    const frameRate = 60;
    const totalFrames = (animationDuration / 1000) * frameRate;
    let frame = 0;
    const initialFill = gaugeFill;

    function animateGauge() {
      frame++;
      gaugeFill = initialFill + (targetFill - initialFill) * (frame / totalFrames);
      drawGauge(gaugeFill, ctx, w, h, goodReps, totalReps);
      if (frame < totalFrames) {
        requestAnimationFrame(animateGauge);
      } else {
        gaugeFill = targetFill;
        drawGauge(gaugeFill, ctx, w, h, goodReps, totalReps);
      }
    }
    animateGauge();
  }

  /*-------------------------------------
    Remote Analysis Display
  -------------------------------------*/
  function displayProcessedResults(data) {
    const resultsContainer = document.getElementById("processedResults");
    resultsContainer.innerHTML = "<h3>Processed Results (Remote):</h3>";

    if (!data || !data["processed_reps"]) {
      resultsContainer.innerHTML += `<p>Error: ${data["error"] || "No processed reps available."}</p>`;
      return;
    }
    const reps = Array.isArray(data["processed_reps"]) ? data["processed_reps"] : [data["processed_reps"]];
    if (reps.length > 0) {
      reps.forEach(rep => {
        let repInfo = `<p>
          Rep ${rep["rep_count"]}: 
          Cluster ${rep["cluster"]}, 
          Max Pitch: ${rep.max_pitch}, 
          Max Gz Up: ${rep.max_gz_up}, 
          Max Gz Down: ${rep.max_gz_down}, 
          Max Az: ${rep.max_az}
        </p>`;
        resultsContainer.innerHTML += repInfo;
      });
    } else {
      resultsContainer.innerHTML += `<p>No processed reps available.</p>`;
    }
  }

  /*-------------------------------------
    End Workout Button
  -------------------------------------*/
  document.getElementById('endWorkoutBtn').addEventListener('click', function() {
    fetch('/end_workout', { method: 'POST' })
      .then(response => response.json())
      .then(data => window.location.href = data.redirect_url);
  });
});
</script>

{% endblock %}
